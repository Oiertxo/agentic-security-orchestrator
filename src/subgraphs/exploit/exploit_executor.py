from langchain_core.messages import HumanMessage
from src.state import AgentState, ExploitState
from src.subgraphs.exploit.exploit_executor_client import call_exploit_engine_cve_lookup, call_exploit_engine
from src.utils import parse_as_json, get_cvss_severity
from src.logger import logger
from langfuse import observe
import json

@observe(name="Exploit executor")
def exploit_executor_node(state: AgentState) -> AgentState:
    old_exploit = state.get("exploit", {}) or {}
    new_step = int(old_exploit.get("step_count", 0)) + 1
    
    current_vulnerabilities = old_exploit.get("vulnerabilities", {})

    analyzed_services = old_exploit.get("analyzed_services", {})
    new_analyzed = {ip: list(ports) for ip, ports in analyzed_services.items()}

    raw = state["messages"][-1].content
    try:
        plan = parse_as_json(raw)
    except Exception:
        result = {"ok": False, "error": "planner_output_not_json", "raw": raw}
        return {
            **state,
            "messages": [HumanMessage(content=f"[SOURCE: exploit_engine]\n{json.dumps(result)}")],
            "exploit": {**old_exploit, "results": (old_exploit.get("results") or []) + [result], "step_count": new_step},
            "next_step": "planner"
        }

    next_tool = plan.get("next_tool")
    args = plan.get("arguments", {})
    target_ip = args.get("target").split(":")[0]
    target_port = args.get("port")
    
    if next_tool == "cve_lookup":
        engine_result = call_exploit_engine_cve_lookup(plan=plan)
        
        if engine_result.get("ok"):
            response = engine_result.get("response") or {}
            items = response.get("items") or []

            filtered_items = [
                item for item in items 
                if (item.get("cvss_v31_base") and item["cvss_v31_base"] >= 8.0) or 
                (item.get("cvss_v2_base") and item["cvss_v2_base"] >= 8.0)
            ]

            for item in filtered_items:
                item['calculated_max_cvss'] = max(filter(None, [item.get('cvss_v31_base'), item.get('cvss_v2_base')]), default=0)
                item['severity_label'] = get_cvss_severity([item.get('cvss_v31_base'), item.get('cvss_v2_base')])
            
            service_key = f"{target_ip}:{target_port}" if target_port else target_ip
            current_vulnerabilities[service_key] = filtered_items

            if target_ip and target_port:
                if target_ip not in new_analyzed:
                    new_analyzed[target_ip] = []
                if target_port not in new_analyzed[target_ip]:
                    new_analyzed[target_ip].append(target_port)
            
            summary = {
                "ok": True,
                "tool": "cve_lookup",
                "target": service_key,
                "count": len(filtered_items),
                "top_cves": [x.get("cve_id") for x in filtered_items[:5]]
            }
        else:
            summary = {"ok": False, "error": engine_result.get("error"), "tool": "cve_lookup"}

    else:
        engine_result = call_exploit_engine(plan=plan)
        
        if engine_result.get("ok"):
            response = engine_result.get("response") or {}
            summary = {
                "ok": True,
                "target": target_ip,
                "tool": next_tool,
                "output": response.get("stdout", "No stdout"),
            }
        else:
            summary = {"ok": False, "error": engine_result.get("error"), "tool": next_tool}

    port_map = state.get("recon", {}).get("port_map", {})
    pending_services = {}

    for ip, ports in port_map.items():
        analyzed_for_ip = new_analyzed.get(ip, [])
        
        for port, info in ports.items():
            if info.get("version") and port not in analyzed_for_ip:
                if ip not in pending_services:
                    pending_services[ip] = []
                pending_services[ip].append(port)
    
    logger.info(f"[EXPLOIT_EXECUTOR] Result summary: {summary}")
    logger.info(f"[EXPLOIT_EXECUTOR] Pending services for CVE lookup: {sum(len(p) for p in pending_services.values())}")

    updated_exploit: ExploitState = {
        **old_exploit,
        "results": (old_exploit.get("results") or []) + [summary],
        "step_count": new_step,
        "vulnerabilities": current_vulnerabilities,
        "analyzed_services": new_analyzed,
        "pending_services": pending_services,
        "finished": False
    }

    return {
        **state,
        "user_target": state.get("user_target"),
        "exploit": updated_exploit,
        "next_step": "planner",
    }