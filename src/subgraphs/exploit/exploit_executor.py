from langchain_core.messages import HumanMessage
from src.state import AgentState, ExploitState
from src.subgraphs.exploit.exploit_executor_client import call_exploit_engine_cve_lookup, call_exploit_engine
from src.utils import parse_as_json
from src.logger import logger
from langfuse import observe
import json

@observe(name="Exploit executor")
def exploit_executor_node(state: AgentState) -> AgentState:
    old_exploit = state.get("exploit", {}) or {}
    new_step = int(old_exploit.get("step_count", 0)) + 1
    
    current_vulnerabilities = old_exploit.get("vulnerabilities", {})
    current_working_target = old_exploit.get("working_target", {})

    raw = state["messages"][-1].content
    try:
        plan = parse_as_json(raw)
    except Exception:
        result = {"ok": False, "error": "planner_output_not_json", "raw": raw}
        return {
            **state,
            "messages": [HumanMessage(content=f"[SOURCE: exploit_engine]\n{json.dumps(result)}")],
            "exploit": {**old_exploit, "results": (old_exploit.get("results") or []) + [result], "step_count": new_step},
            "next_step": "planner"
        }

    next_tool = plan.get("next_tool")
    args = plan.get("arguments", {})
    target_ip = args.get("target")
    target_port = args.get("port")
    
    if target_ip:
        current_working_target = {
            "ip": target_ip,
            "port": target_port,
            "service": args.get("service"),
            "product": args.get("product")
        }

    if next_tool == "cve_lookup":
        engine_result = call_exploit_engine_cve_lookup(plan=plan)
        
        if engine_result.get("ok"):
            response = engine_result.get("response") or {}
            items = response.get("items") or []
            
            service_key = f"{target_ip}:{target_port}" if target_port else target_ip
            current_vulnerabilities[service_key] = items
            
            summary = {
                "ok": True,
                "tool": "cve_lookup",
                "target": service_key,
                "count": len(items),
                "top_cves": [x.get("cve_id") for x in items[:5]]
            }
        else:
            summary = {"ok": False, "error": engine_result.get("error"), "tool": "cve_lookup"}

    else:
        engine_result = call_exploit_engine(plan=plan)
        
        if engine_result.get("ok"):
            response = engine_result.get("response") or {}
            summary = {
                "ok": True,
                "target": target_ip,
                "tool": next_tool,
                "output": response.get("stdout", "No stdout"),
            }
        else:
            summary = {"ok": False, "error": engine_result.get("error"), "tool": next_tool}

    logger.info(f"[EXPLOIT_EXECUTOR] Result summary: {summary}")

    updated_exploit: ExploitState = {
        **old_exploit,
        "results": (old_exploit.get("results") or []) + [summary],
        "step_count": new_step,
        "vulnerabilities": current_vulnerabilities,
        "working_target": current_working_target,
        "finished": False,
    }

    return {
        **state,
        "user_target": state.get("user_target"),
        "exploit": updated_exploit,
        "next_step": "planner",
    }