import time, httpx
from src.utils import get_engine_url
from typing import Optional, Dict, Any
from src.logger import logger
from langfuse import observe

def _normalize_cve_lookup_payload(
    *,
    args: Optional[Dict[str, Any]] = None,
    plan: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Normalizes either:
      - args={product, version, service, vendor, ostype, extrainfo, port, resultsPerPage, maxResults}
      - plan={"next_tool":"cve_lookup", "arguments":{...}}
    into the /cve_lookup request schema.

    Raises ValueError if required fields are missing.
    """
    if plan is not None:
        next_tool = plan.get("next_tool")
        if next_tool != "cve_lookup":
            raise ValueError(f"Exploit executor only supports next_tool='cve_lookup' for MVP, got: {next_tool}")
        arguments = plan.get("arguments", {}) or {}
    else:
        arguments = args or {}

    product = arguments.get("product")
    if not product or not isinstance(product, str):
        raise ValueError("Missing required 'product' (string) for cve_lookup.")

    payload: Dict[str, Any] = {
        "product": product,
        "version": arguments.get("version"),
        "service": arguments.get("service"),
        "vendor": arguments.get("vendor"),
        "ostype": arguments.get("ostype"),
        "extrainfo": arguments.get("extrainfo"),
        "port": arguments.get("port"),
    }

    port = payload.get("port")
    if port is not None:
        try:
            port_int = int(port)
            if port_int < 1 or port_int > 65535:
                raise ValueError
            payload["port"] = port_int
        except Exception:
            raise ValueError("'port' must be an int between 1 and 65535.")

    payload = {k: v for k, v in payload.items() if v is not None}
    return payload


@observe(name="Exploit engine cve lookup")
def call_exploit_engine_cve_lookup(
    *,
    args: Optional[Dict[str, Any]] = None,
    plan: Optional[Dict[str, Any]] = None,
    base_url: Optional[str] = None,
    timeout: float = 30.0,
    retries: int = 2,
    backoff_base: float = 0.5,
) -> Dict[str, Any]:
    """
    Calls the engine /cve_lookup endpoint using structured inputs.
    Returns a consistent {ok, status_code, request, response, error} dict.
    """
    payload = _normalize_cve_lookup_payload(args=args, plan=plan)

    base = (base_url or get_engine_url()).rstrip("/")
    url = f"{base}/cve_lookup"

    last_exc: Optional[Exception] = None

    for attempt in range(retries + 1):
        try:
            with httpx.Client(timeout=timeout) as client:
                resp = client.post(url, json=payload, headers={"Content-Type": "application/json"})

            data = None
            try:
                data = resp.json()
            except Exception:
                data = None

            if isinstance(data, dict):
                count = data.get("count")
                logger.info(f"[EXPLOIT_EXECUTOR_CLIENT] CVE lookup ok={resp.status_code<400} product={payload.get('product')} count={count}")
                pass

            if resp.status_code < 400:
                return {
                    "ok": True,
                    "status_code": resp.status_code,
                    "request": payload,
                    "response": data,
                    "error": None,
                }

            return {
                "ok": False,
                "status_code": resp.status_code,
                "request": payload,
                "response": data,
                "error": (data.get("detail") if isinstance(data, dict) and "detail" in data
                          else f"HTTP {resp.status_code}"),
            }

        except (httpx.ConnectError, httpx.ReadTimeout, httpx.HTTPError) as e:
            last_exc = e
            if attempt < retries:
                time.sleep(backoff_base * (2 ** attempt))
                continue

    return {
        "ok": False,
        "status_code": None,
        "request": payload,
        "response": None,
        "error": str(last_exc) if last_exc else "Unknown transport error",
    }

@observe(name="Exploit engine")
def call_exploit_engine(plan):
    # MOCK IMPLEMENTATION
    target = plan.get("arguments", {}).get("target", "10.255.255.10")
    exploit = plan.get("next_tool", "ssh entry")

    return {
        "ok": True,
        "response": {
            "target": target,
            "exploit_used": exploit,
            "stdout": "Exploit executed successfully, remote shell obtained",
            "stderr": "",
            "success": True,
        }
    }