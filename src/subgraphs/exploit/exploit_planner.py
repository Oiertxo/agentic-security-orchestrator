from langchain_core.messages import HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate
from src.model import get_model
from src.state import AgentState, ExploitState, PlannerOutput
from src.schemas import ExploitPlannerSchema
from src.utils import load_prompt
from src.logger import logger
from typing import Dict, Any, cast
from langfuse import observe
import json

@observe(name="Exploit planner")
def exploit_planner_node(state: AgentState) -> AgentState:
    llm = get_model()
    system_prompt = load_prompt("exploit.txt")

    recon_state = state.get("recon") or {}
    exploit_state = state.get("exploit") or {}

    logger.info(f"[EXPLOIT_PLANNER] State received: {state}")
    
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        ("system", "Port map (host: open ports): {port_map}"),
        ("system", "Execution Results: {results}"),
        ("system", "Attempted actions: {attempted}"),
        ("system", "Analyzed services for CVE lookup: {analyzed_services}"),
        ("system", "Pending services for CVE lookup: {pending_services}")
    ])

    planner_input = {
        "port_map": recon_state.get("port_map", {}),
        "results": exploit_state.get("results") or [],
        "attempted": exploit_state.get("attempted") or [],
        "analyzed_services": exploit_state.get("analyzed_services", {}),
        "pending_services": exploit_state.get("pending_services", {}),
    }

    logger.info(f"[EXPLOIT_PLANNER] Calling LLM with intel: {planner_input}")
    
    chain = (prompt | llm.with_structured_output(ExploitPlannerSchema, method="json_mode", strict=True)).with_types(
        input_type=Dict[str, Any],
        output_type=ExploitPlannerSchema,
    )

    try:
        result = ExploitPlannerSchema.model_validate(chain.invoke(planner_input))
        data = result.model_dump(mode="json")
    except Exception as e:
        logger.error(f"[EXPLOIT_PLANNER] Parsing error: {e}")
        data = {"finished": True, "next_tool": None, "arguments": {}}

    logger.info(f"[EXPLOIT_PLANNER] Response from LLM: {data}")
    
    if not data or (not data.get("finished") and not data.get("next_tool")):
        logger.error(f"[EXPLOIT_PLANNER] Planner failed to reason. Forcing termination")
        data = {
            "finished": True,
            "next_tool": None,
            "arguments": {},
        }

    is_finished = data.get("finished", False)
    new_planner: PlannerOutput = {
        "next_tool": data.get("next_tool", ""),
        "arguments": data.get("arguments", {}),
    }
    new_exploit: ExploitState = {
        **exploit_state,
        "planner": new_planner,
        "finished": is_finished,
    }

    return {
        **state,
        "exploit": new_exploit,
        "messages": state.get("messages") + [AIMessage(content=json.dumps(data))],
        "next_step": "supervisor" if is_finished else "executor"
    }